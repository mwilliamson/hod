export parseInt;

import Options from .Options;
// TODO: Use Bytes instead
import CodePoints from .Strings.CodePoints;

fun parseInt(text: String) -> Option[Int] {
    val first = CodePoints.first(text);
    first |> Options.flatMap ~ (fun (codePoint: CodePoint) =>
        if (codePoint == '-') {
            parsePositiveInt(CodePoints.dropLeft(1, text))
                |> Options.map ~ (fun (value: Int) => -value)
        } else {
            parsePositiveInt(text)
        }
    )
}

fun parsePositiveInt(text: String) -> Option[Int] {
    if (CodePoints.isEmpty(text)) {
        none
    } else {
        CodePoints.foldLeft(
            fun (acc: Option[Int], codePoint: CodePoint) -> Option[Int] {
                Options.flatMap(
                    fun (acc: Int) -> Option[Int] {
                        if (codePoint >= '0' && codePoint <= '9') {
                            val digit = CodePoints.codePointToInt(codePoint) - CodePoints.codePointToInt('0');
                            some(acc * 10 + digit)
                        } else {
                            none
                        }
                    },
                    acc,
                )
            },
            some(0),
            text
        )
    }
}
