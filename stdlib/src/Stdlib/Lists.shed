export
    List,
    cons,
    nil,
    list,

    sequenceToList,

    all,
    any,
    flatten,
    forEach,
    map,
    reduce;

import Sequences from .Sequences;

// TODO: use function composition

union List[+T] =
    | Cons[T] {
        head: T,
        tail: List[T],
    }
    | Nil;

fun cons[T](head: T, tail: List[T]) -> List[T] {
    Cons(.head = head, .tail = tail)
}

val nil = Nil();

varargs list(cons, nil);

fun listToSequence[T](list: List[T]) -> Sequences.Sequence[T, Pure] {
    Sequences.Sequence[T, Pure](
        .next = fun() =>
            when (list) {
                is Nil {
                    Sequences.end
                }
                is Cons {
                    Sequences.SequenceItem(.head = list.head, .tail = listToSequence(list.tail))
                }
            },
    )
}

fun sequenceToList[T, !E](sequence: Sequences.Sequence[T, E]) !E -> List[T] {
    reverse(Sequences.reduce!(
        fun(acc: List[T], element: T) => cons(element, acc),
        nil,
        sequence,
    ))
}

fun all(elements: List[Bool]) -> Bool {
    Sequences.all(listToSequence(elements))
}

fun any(elements: List[Bool]) -> Bool {
    Sequences.any(listToSequence(elements))
}

fun flatten[T](lists: List[List[T]]) -> List[T] {
    sequenceToList(
        Sequences.lazyFlatten(
            Sequences.lazyMap(fun (list: List[T]) => listToSequence(list), listToSequence(lists)),
        ),
    )
}

fun forEach[T, !E](func: Fun (T) !E -> Unit, elements: List[T]) !E -> Unit {
    Sequences.forEach!(func, listToSequence(elements))
}

fun map[T, R, !E](func: Fun (T) !E -> R, elements: List[T]) !E -> List[R] {
    sequenceToList!(
        Sequences.lazyMap(func, listToSequence(elements)),
    )
}

fun reduce[T, R, !E](func: Fun (R, T) !E -> R, initial: R, elements: List[T]) !E -> R {
    Sequences.reduce!(
        func,
        initial,
        listToSequence(elements),
    )
}

fun reverse[T](elements: List[T]) -> List[T] {
    reverse2(nil, elements)
}

fun reverse2[T](acc: List[T], elements: List[T]) -> List[T] {
    when (elements) {
        is Nil {
            acc
        }
        is Cons {
            tailrec reverse2(cons(elements.head, acc), elements.tail)
        }
    }
}
