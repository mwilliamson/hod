export
    codePointToHexString,
    codePointToInt,
    codePointToString,
    count,
    first,
    flatMap,
    foldLeft,
    replace,
    slice,

    dropLeft,
    isEmpty,
    join,
    left,
    leftWhile,
    padLeft,
    startsWith;

import Lists from Stdlib.Lists;
import @(.List as List) from Stdlib.Lists;
import Options from Stdlib.Options;
import Strings from Stdlib.Platform.Strings;
import Predicates from Stdlib.Predicates;
import Repeat from Stdlib.Repeat;
import Sequences from Stdlib.Sequences;

val codePointToHexString = Strings.codePointToHexString;
val codePointToInt = Strings.codePointToInt;
val codePointToString = Strings.codePointToString;
val count = Strings.codePointCount;
val replace = Strings.replace;
val slice = Strings.substring;

fun stringToSequence(value: String) -> Sequences.Sequence[CodePoint, Pure] {
    stringToSequenceAtIndex(Strings.zeroIndex, value)
}

fun stringToSequenceAtIndex(index: StringIndex, value: String) -> Sequences.Sequence[CodePoint, Pure] {
    Sequences.pure[CodePoint](fun () {
        val next = Strings.next(index, value);
        when (next) {
            is None {
                Sequences.end
            }
            is Some {
                val #(codePoint, nextIndex) = next.value;
                Sequences.item(codePoint, stringToSequenceAtIndex(nextIndex, value))
            }
        }
    })
}

fun dropLeft(toDrop: Int, value: String) -> String {
    Strings.substring(toDrop, count(value), value)
}

fun first(value: String) -> Option[CodePoint] {
    val next = Strings.next(Strings.zeroIndex, value);
    when (next) {
        is Some {
            val #(codePoint, nextIndex) = next.value;
            some(codePoint)
        }
        is None {
            none
        }
    }
}

fun flatMap(func: Fun (CodePoint) -> String, value: String) -> String {
    foldLeft(
        fun (acc: String, codePoint: CodePoint) => acc + func(codePoint),
        "",
        value,
    )
}

fun foldLeft[T](func: Fun (T, CodePoint) -> T, initial: T, value: String) -> T {
    Sequences.foldLeft(
        func,
        initial,
        stringToSequence(value),
    )
}

fun isEmpty(value: String) -> Bool {
    value == ""
}

fun join(separator: String, elements: List[String]) -> String {
    Lists.foldLeft(
        fun (text: String, element: String) -> String {
            if (text == "") {
                element
            } else {
                text + separator + element
            }
        },
        "",
        elements
    )
}

fun left(count: Int, value: String) -> String {
    Strings.substring(0, count, value)
}

fun leftWhile(predicate: Fun (CodePoint) -> Bool, value: String) -> String {
    val index = Sequences.findIndex(Predicates.negate(predicate), stringToSequence(value));
    when (index) {
        is None {
            value
        }
        is Some {
            left(index.value, value)
        }
    }
}

fun padLeft(desiredLength: Int, padding: CodePoint, string: String) -> String {
    repeat(codePointToString(padding), desiredLength - count(string)) + string
}

fun repeat(value: String, times: Int) -> String {
    Repeat.repeat(fun (acc: String) => acc + value, times, "")
}

fun startsWith(prefix: String, value: String) -> Bool {
    left(count(prefix), value) == prefix
}
