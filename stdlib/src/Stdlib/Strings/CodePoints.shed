export
    codePointToHexString,
    codePointToInt,
    codePointToString,
    length,
    first,
    flatMap,
    foldLeft,
    replace,
    slice,

    dropLeft,
    isEmpty,
    join,
    left,
    leftWhile,
    padLeft,
    startsWith;

import Lists from Stdlib.Lists;
import @(.List as List) from Stdlib.Lists;
import Options from Stdlib.Options;
import Strings from Stdlib.Platform.Strings;
import Sequences from Stdlib.Sequences;

val codePointToHexString = Strings.codePointToHexString;
val codePointToInt = Strings.codePointToInt;
val codePointToString = Strings.codePointToString;
val length = Strings.codePointCount;
val replace = Strings.replace;
val slice = Strings.substring;

fun stringToSequence(value: String) -> Sequences.Sequence[CodePoint, Pure] {
    stringToSequenceAtIndex(0, value)
}

fun stringToSequenceAtIndex(index: Int, value: String) -> Sequences.Sequence[CodePoint, Pure] {
    Sequences.Sequence[CodePoint, Pure](
        .next = fun () -> Sequences.SequenceIterator[CodePoint, Pure] {
            val codePoint = Strings.codePointAt(index, value);
            when (codePoint) {
                is Options.None {
                    Sequences.end
                }
                is Options.Some {
                    Sequences.SequenceItem(
                        .head = codePoint.value,
                        .tail = stringToSequenceAtIndex(index + 1, value),
                    )
                }
            }
        },
    )
}

fun dropLeft(count: Int, value: String) -> String {
    Strings.substring(count, length(value), value)
}

fun first(value: String) -> Options.Option[CodePoint] {
    Strings.codePointAt(0, value)
}

fun flatMap(func: Fun (CodePoint) -> String, value: String) -> String {
    foldLeft(
        fun (acc: String, codePoint: CodePoint) => acc + func(codePoint),
        "",
        value,
    )
}

fun foldLeft[T](func: Fun (T, CodePoint) -> T, initial: T, value: String) -> T {
    Sequences.reduce(
        func,
        initial,
        stringToSequence(value),
    )
}

fun isEmpty(value: String) -> Bool {
    Strings.codePointCount(value) == 0
}

fun join(separator: String, elements: List[String]) -> String {
    Lists.reduce(
        fun (text: String, element: String) -> String {
            if (text == "") {
                element
            } else {
                text + separator + element
            }
        },
        "",
        elements
    )
}

fun left(count: Int, value: String) -> String {
    Strings.substring(0, count, value)
}

fun leftWhile(predicate: Fun (CodePoint) -> Bool, value: String) -> String {
    // TODO: a better implementation
    val takeNext = first(value)
        |> Options.map ~ (predicate)
        |> Options.default ~ (false);
    if (takeNext) {
        left(1, value) + leftWhile(predicate, dropLeft(1, value))
    } else {
        ""
    }
}

fun padLeft(desiredLength: Int, padding: CodePoint, string: String) -> String {
    repeat(codePointToString(padding), desiredLength - length(string)) + string
}

fun repeat(value: String, times: Int) -> String {
    repeat2("", value, times)
}

// TODO: tailrec
fun repeat2(acc: String, value: String, times: Int) -> String {
    if (times == 0) {
        acc
    } else {
        repeat2(acc + value, value, times - 1)
    }
}

fun startsWith(prefix: String, value: String) -> Bool {
    left(length(prefix), value) == prefix
}
