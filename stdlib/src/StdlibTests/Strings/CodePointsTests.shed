export testCases;

import Lists from Stdlib.Lists;
import @(.list as list) from Stdlib.Lists;
import Matchers from Stdlib.Matchers;
import CodePoints from Stdlib.Strings.CodePoints;
import Tests from Stdlib.Tests;

val foldLeftTestSuite = Tests.suite("foldLeft", list(
    Tests.testCase("empty string produces initial value", fun () {
        val result = CodePoints.foldLeft(fun (acc: Int, codePoint: CodePoint) => acc + 1, 0, "");
        Tests.assertThat(result, Matchers.isInt(0))
    }),

    Tests.testCase("code points outside BMP are treated as single code point", fun () {
        val result = CodePoints.foldLeft(fun (acc: Int, codePoint: CodePoint) => acc + 1, 0, "☃𝔼☃𝔼☃");
        Tests.assertThat(result, Matchers.isInt(5))
    }),
));

val joinTestSuite = Tests.suite("join", list(
    Tests.testCase("empty iterable is joined to empty string", fun () {
        val result = CodePoints.join(", ", list());
        Tests.assertThat(result, Matchers.isString(""))
    }),

    Tests.testCase("singleton iterable is joined without separator", fun () {
        val result = CodePoints.join(", ", list("apple"));
        Tests.assertThat(result, Matchers.isString("apple"))
    }),

    Tests.testCase("iterable with multiple values is joined with separator", fun () {
        val result = CodePoints.join(", ", list("apple", "banana", "coconut"));
        Tests.assertThat(result, Matchers.isString("apple, banana, coconut"))
    }),
));

fun lengthTestCase(string: String, expectedCount: Int) -> Tests.TestCase {
    Tests.testCase(string, fun () {
        val count = CodePoints.length(string);
        Tests.assertThat(count, Matchers.isInt(expectedCount))
    })
}

val lengthTestSuite = Tests.suite("length", list(
    lengthTestCase("", 0),
    lengthTestCase("a", 1),
    lengthTestCase("abc", 3),
    lengthTestCase("☃", 1),
    lengthTestCase("𝔼", 1),
    lengthTestCase("☃𝔼☃𝔼☃", 5),
));

val testCases = Tests.suite(moduleName, list(
    foldLeftTestSuite,
    joinTestSuite,
    lengthTestSuite,
));

