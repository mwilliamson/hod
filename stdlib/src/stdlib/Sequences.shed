shape Sequence[T, !E] {
    next: () !E -> SequenceIterator[T, E],
}

shape SequenceEnd {
}

val end = SequenceEnd();

shape SequenceItem[T, !E] {
    head: T,
    tail: Sequence[T, E],
}

union SequenceIterator[T, !E] = SequenceItem[T, E] | SequenceEnd;

fun all[!E](sequence: Sequence[Bool, E]) !E -> Bool {
    val item = sequence.next();
    when (item) {
        is SequenceEnd {
            true
        }
        // TODO: allow "is options.Some" (without type arguments)
        is SequenceItem[Bool, E] {
            if (item.head) {
                all(item.tail)
            } else {
                false
            }
        }
    }
}

fun any[!E](sequence: Sequence[Bool, E]) !E -> Bool {
    val item = sequence.next();
    when (item) {
        is SequenceEnd {
            false
        }
        is SequenceItem[Bool, E] {
            if (item.head) {
                true
            } else {
                any(item.tail)
            }
        }
    }
}

fun forEach[T, !E](func: (T) !E -> Unit, sequence: Sequence[T, E]) !E -> Unit {
    val item = sequence.next();
    when (item) {
        is SequenceEnd {
        }
        is SequenceItem[T, E] {
            func(item.head);
            forEach(func, item.tail);
        }
    }
}

fun lazyMap[T, R, !E](func: (T) !E -> R, sequence: Sequence[T, E]) -> Sequence[R, E] {
    Sequence(
        next = fun () !E -> SequenceIterator[R, E] {
            val item = sequence.next();
            when (item) {
                is SequenceEnd {
                    end
                }
                is SequenceItem[T, E] {
                    SequenceItem(
                        head = func(item.head),
                        tail = lazyMap(func, item.tail),
                    )
                }
            }
        }
    )
}

fun reduce[T, R, !E](func: (R, T) !E -> R, initial: R, sequence: Sequence[T, E]) !E -> R {
    val item = sequence.next();
    when (item) {
        is SequenceEnd {
            initial
        }
        is SequenceItem[T, E] {
            reduce(func, func(initial, item.head), item.tail)
        }
    }
}
