import .options;

fun anything() -> Matcher[Any] {
    return Matcher(
        description = "anything",
        match = fun (x: Any) => success,
    );
}

fun isInteger(value: Int) -> Matcher[Int] {
    return describingMatcher(
        value,
        fun (integer: Int) => intToString(integer),
        fun (actual: Int) => actual == value,
    );
}

fun isString(value: String) -> Matcher[String] {
    return describingMatcher(
        value,
        fun (string: String) => string,
        fun (actual: String) => actual == value,
    );
}

fun isNone() -> Matcher[options.Option[Any]] {
    // TODO: remove need for explicit type arguments
    return Matcher[options.Option[Any]](
        description = "none",
        match = fun (actual: options.Option[Any]) -> Result {
            if (actual is options.None) {
                return success;
            } else {
                return failure("was some()");
            }
        }
    );
}

fun isSome[T](matcher: Matcher[T]) -> Matcher[options.Option[T]] {
    // TODO: remove need for explicit type arguments
    return Matcher[options.Option[T]](
        description = "option with value " + matcher.description,
        match = fun (actual: options.Option[T]) -> Result {
            if (actual is options.Some[T]) {
                return matcher.match(actual.value);
            } else {
                return failure("was none");
            }
        }
    );
}

fun describingMatcher[T](
    value: T,
    toString: (T) -> String,
    match: (T) -> Bool
) -> Matcher[T] {
    return Matcher(
        description = toString(value),
        match = fun (actual: T) -> Result {
            if (match(actual)) {
                return success;
            } else {
                return failure("was " + toString(actual));
            }
        },
    );
}

shape Matcher[-T] {
    description: String,
    match: (T) -> Result,
}

union Result = Success | Failure;
shape Success memberOf Result { }
shape Failure memberOf Result {
    message: String,
}
val success = Success();
fun failure(message: String) -> Failure {
    return Failure(message=message);
}
