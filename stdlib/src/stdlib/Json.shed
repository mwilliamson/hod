import stdlib.Lists;
import stdlib.Sequences;
import stdlib.Strings;


union JsonValue = JsonObject | JsonArray | JsonNumber | JsonString | JsonBoolean | JsonNull;

shape JsonObject {
    properties: List[JsonProperty],
}

fun object(properties: List[JsonProperty]) -> JsonValue {
    JsonObject(properties = properties)
}

shape JsonProperty {
    key: String,
    value: JsonValue,
}

fun property(key: String, value: JsonValue) -> JsonProperty {
    JsonProperty(key = key, value = value)
}

shape JsonArray {
    elements: List[JsonValue],
}

fun array(elements: List[JsonValue]) -> JsonValue {
    JsonArray(elements = elements)
}

shape JsonNumber {
    value: String,
}

fun number(value: String) -> JsonValue {
    JsonNumber(value = value)
}

shape JsonString {
    value: String,
}

fun string(value: String) -> JsonValue {
    JsonString(value = value)
}

shape JsonBoolean {
    value: Bool,
}

fun boolean(value: Bool) -> JsonValue {
    JsonBoolean(value = value)
}

shape JsonNull {
}

val null = JsonNull();

fun valueToText(value: JsonValue) -> String {
    when (value) {
        is JsonObject {
            val properties = Strings.join(",", Lists.map(propertyToText, value.properties));
            "{" + properties + "}"
        }
        is JsonArray {
            val elements = Strings.join(",", Lists.map(valueToText, value.elements));
            "[" + elements +  "]"
        }
        is JsonNumber {
            value.value
        }
        is JsonString {
            jsonStringToText(value.value)
        }
        is JsonBoolean {
            if (value.value) {
                "true"
            } else {
                "false"
            }
        }
        is JsonNull {
            "null"
        }
    }
}

fun propertyToText(property: JsonProperty) -> String {
    jsonStringToText(property.key) + ":" + valueToText(property.value)
}

fun jsonStringToText(value: String) -> String {
    val characters = Strings.mapCharacters(jsonStringCharacterToText, value);
    "\"" + characters + "\""
}

fun jsonStringCharacterToText(character: Char) -> String {
    if (character == '\\') {
        "\\\\"
    } else if (character == '\"') {
        "\\\""
    } else if (character == '\t') {
        "\\t"
    } else if (character == '\n') {
        "\\n"
    } else if (character == '\r') {
        "\\r"
    } else if (character < '\u{20}') {
        val hexString = Strings.charToHexString(character);
        "\\u" + Strings.padLeft(4, '0', hexString)
    } else {
        Strings.charToString(character)
    }
}

fun textToValue(text: String) -> JsonValue {
    val isNotWhitespace = fun (token: Token) -> Bool {
        // TODO: implement negation
        if (token.tokenType is TokenWhitespace) {
            false
        } else {
            true
        }
    };

    val tokens = tokenise(text) |> Sequences.lazyFilter ~ (isNotWhitespace);
    tokensToValue(tokens)
}

fun tokensToValue(tokens: Sequences.Sequence[Token, Pure]) -> JsonValue {
    val iterator = tokens.next();
    when (iterator) {
        is Sequences.SequenceEnd {
            null
        }
        is Sequences.SequenceItem[Token, Pure] {
            when (iterator.head.tokenType) {
                is TokenTrue {
                    boolean(true)
                }
                is TokenFalse {
                    boolean(false)
                }
                is TokenNull {
                    null
                }
                is TokenWhitespace {
                    null
                }
                is TokenUnexpected {
                    null
                }
            }
        }
    }
}

shape TokenWhitespace {}
shape TokenNull {}
shape TokenTrue {}
shape TokenFalse {}
shape TokenUnexpected {}
union TokenType = TokenWhitespace | TokenNull | TokenTrue | TokenFalse | TokenUnexpected;

shape Token {
    tokenType: TokenType,
    value: String,
}

fun token(tokenType: TokenType, value: String) -> Token {
    Token(tokenType = tokenType, value = value)
}

fun tokenise(value: String) -> Sequences.Sequence[Token, Pure] {
    Sequences.Sequence(
        next = fun () -> Sequences.SequenceIterator[Token, Pure] {
            if (Strings.isEmpty(value)) {
                Sequences.end
            } else {
                val token = nextToken(value);
                val remainder = Strings.dropLeft(Strings.codePointCount(token.value), value);
                Sequences.SequenceItem(
                    head = token,
                    tail = tokenise(remainder),
                )
            }
        },
    )
}

fun nextToken(value: String) -> Token {
    if (Strings.startsWith("true", value)) {
        token(TokenTrue(), "true")
    } else if (Strings.startsWith("false", value)) {
        token(TokenFalse(), "false")
    } else if (Strings.startsWith("null", value)) {
        token(TokenNull(), "null")
    } else if (Strings.startsWith(" ", value)) {
        // TODO: consume all whitespace in one token
        // TODO: handle other whitespace characters
        token(TokenWhitespace(), " ")
    } else {
        token(TokenUnexpected(), Strings.left(1, value))
    }
}

fun equals(left: JsonValue, right: JsonValue) -> Bool {
    if (left is JsonNull) {
        right is JsonNull
    } else if (left is JsonBoolean) {
        if (right is JsonBoolean) {
            left.value == right.value
        } else {
            false
        }
    } else {
        false
    }
}
