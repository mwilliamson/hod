import stdlib.Lists;
import stdlib.Options;
import stdlib.platform.Strings;

val codePointToHexString = Strings.codePointToHexString;
val codePointToString = Strings.codePointToString;
val length = Strings.codePointCount;
val firstCodePoint = Strings.firstCodePoint;
val mapCodePoints = Strings.mapCodePoints;
val replace = Strings.replace;

fun dropLeft(count: Int, value: String) -> String {
    Strings.substring(count, length(value), value)
}

fun isEmpty(value: String) -> Bool {
    Strings.codePointCount(value) == 0
}

fun join(separator: String, elements: List[String]) -> String {
    Lists.reduce(
        fun (text: String, element: String) -> String {
            if (text == "") {
                element
            } else {
                text + separator + element
            }
        },
        "",
        elements
    )
}

fun left(count: Int, value: String) -> String {
    Strings.substring(0, count, value)
}

fun leftWhile(predicate: (Char) -> Bool, value: String) -> String {
    // TODO: a better implementation
    val takeNext = firstCodePoint(value)
        |> Options.map ~ (predicate)
        |> Options.default ~ (false);
    if (takeNext) {
        left(1, value) + leftWhile(predicate, dropLeft(1, value))
    } else {
        ""
    }
}

fun padLeft(desiredLength: Int, padding: Char, string: String) -> String {
    Strings.repeat(codePointToString(padding), desiredLength - length(string)) + string
}

fun startsWith(prefix: String, value: String) -> Bool {
    left(length(prefix), value) == prefix
}
