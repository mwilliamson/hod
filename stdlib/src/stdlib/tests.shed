import .Lists;
import .matchers;
import .options;


shape AssertionError {
    message: String,
}

fun fail(message: String) -> AssertionResult {
    AssertionResult(error = options.some(AssertionError(message = message)))
}

fun assert(value: Bool) -> AssertionResult {
    if (value) {
        AssertionResult(error = options.none)
    } else {
        fail("value was false")
    }
}

fun assertThat[T](value: T, matcher: matchers.Matcher[T]) -> AssertionResult {
    val result = matcher.match(value);
    when (result) {
        is matchers.Failure {
            val message = "expected " + matcher.description + "\nbut " + result.message;
            val error = AssertionError(message = message);
            AssertionResult(error = options.some(error))
        }
        is matchers.Success {
            AssertionResult(error = options.none)
        }
    }
}

shape AssertionResult {
    error: options.Option[AssertionError],
}

union Test = TestCase | TestSuite;
union TestResult = TestCaseResult | TestSuiteResult;

shape TestCase memberOf Test {
    name: String,
    run: () -> AssertionResult,
}

shape TestCaseResult memberOf TestResult {
    name: String,
    error: options.Option[AssertionError],
}

fun testCase(name: String, run: () -> AssertionResult) -> TestCase {
    TestCase(name = name, run = run)
}

shape TestSuite memberOf Test {
    name: String,
    tests: List[Test],
}

shape TestSuiteResult memberOf TestResult {
    name: String,
    results: List[TestResult],
}

fun suite(name: String, tests: List[Test]) -> Test {
    TestSuite(name = name, tests = tests)
}

fun main() -> Int {
    0
}

val greenCode = "\u001B[32m";
val redCode = "\u001B[31m";
val blackCode = "\u001B[39m";

fun runTests(tests: List[Test]) !Io -> Int {
    val results = Lists.map(runTest ~ (depth = 0), tests);
    print("\n");
    Lists.forEach(printFailures, results);

    val counts = countTestResults(results);

    print(intToString(counts.successes) + " tests passed, ");
    print(intToString(counts.failures) + " tests failed\n");

    if (counts.failures == 0) {
        0
    } else {
        1
    }
}

fun countTestResults(results: List[TestResult]) -> TestCounts {
    Lists.reduce(
        fun (counts: TestCounts, result: TestResult) =>
            addTestCounts(counts, countTestResult(result)),
        TestCounts(failures = 0, successes = 0),
        results,
    )
}

fun countTestResult(result: TestResult) -> TestCounts {
    when (result) {
        is TestCaseResult {
            when (result.error) {
                is options.Some[AssertionError] {
                    TestCounts(failures = 1, successes = 0)
                }
                is options.None {
                    TestCounts(failures = 0, successes = 1)
                }
            }
        }
        is TestSuiteResult {
            countTestResults(result.results)
        }
    }
}

fun addTestCounts(counts1: TestCounts, counts2: TestCounts) -> TestCounts {
    TestCounts(
        failures = counts1.failures + counts2.failures,
        successes = counts1.successes + counts2.successes,
    )
}

shape TestCounts {
    failures: Int,
    successes: Int,
}

fun printFailures(result: TestResult) !Io -> Unit {
    // TODO: formatting of suites
    when (result) {
        is TestCaseResult {
            val error = result.error;
            if (error is options.Some[AssertionError]) {
                print("\n");
                print(redCode);
                print("✖ ");
                print(result.name);
                print(":\n");
                print(error.value.message);
                print(blackCode);
                print("\n\n");
            }
        }
        is TestSuiteResult {
            Lists.forEach(printFailures, result.results);
        }
    }
}

fun runTest(test: Test, *, depth: Int) !Io -> TestResult {
    when (test) {
        is TestCase {
            val result = test.run();
            val error = result.error;

            when (error) {
                is options.Some[AssertionError] {
                    print(redCode);
                    print("✖");
                }
                is options.None {
                    print(greenCode);
                    print("✔");
                }
            }
            print(blackCode);
            TestCaseResult(name = test.name, error = result.error)
        }
        is TestSuite {
            // TODO: printing of suite names
            // TODO: indentation
            val results = Lists.map(runTest ~ (depth = depth + 1), test.tests);
            TestSuiteResult(name = test.name, results = results)
        }
    }
}
